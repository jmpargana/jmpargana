import { __rest } from './external/.pnpm/tslib@2.3.1/external/tslib/tslib.es6.js';
import { _merge, deepSet, deepSome, isFormControl, getFormDefaultValues, _cloneDeep, debounce, _defaultsDeep, _get, getPath, isSelectElement, shouldIgnore, getInputTextOrNumber, _set, isInputElement, _isPlainObject, _unset, isElement, getFormControls } from '@felte/common';
import { get } from './get.js';
import { createEventConstructors } from './events.js';
import { FelteSubmitError } from './error.js';
import { deepSetTouched } from './deep-set-touched.js';
import { deepRemoveKey } from './deep-set-key.js';

function createDefaultSubmitHandler(form) {
    if (!form)
        return;
    return async function onSubmit() {
        let body = new FormData(form);
        const action = new URL(form.action);
        const method = form.method.toLowerCase() === 'get'
            ? 'get'
            : action.searchParams.get('_method') || form.method;
        let enctype = form.enctype;
        if (form.querySelector('input[type="file"]')) {
            enctype = 'multipart/form-data';
        }
        if (method === 'get' || enctype === 'application/x-www-form-urlencoded') {
            body = new URLSearchParams(body);
        }
        let fetchOptions;
        if (method === 'get') {
            body.forEach((value, key) => {
                action.searchParams.append(key, value);
            });
            fetchOptions = { method };
        }
        else {
            fetchOptions = {
                method,
                body,
                headers: {
                    'Content-Type': enctype,
                },
            };
        }
        const response = await window.fetch(action.toString(), fetchOptions);
        if (response.ok)
            return response;
        throw new FelteSubmitError('An error occurred while submitting the form', response);
    };
}
function createFormAction({ helpers, stores, config, extender, validateErrors, validateWarnings, _setFormNode, _getFormNode, _getInitialValues, _setCurrentExtenders, _getCurrentExtenders, }) {
    const { setFields, setTouched, reset, setInitialValues } = helpers;
    const { addValidator, addTransformer, validate, setIsDirty, setIsSubmitting } = helpers, contextHelpers = __rest(helpers, ["addValidator", "addTransformer", "validate", "setIsDirty", "setIsSubmitting"]);
    const { data, errors, warnings, touched, isSubmitting, isDirty, interacted, } = stores;
    function createSubmitHandler(altConfig) {
        return async function handleSubmit(event) {
            var _a, _b, _c, _d, _e, _f, _g;
            const formNode = _getFormNode();
            const { createErrorEvent, createSubmitEvent, createSuccessEvent, } = createEventConstructors();
            const submitEvent = createSubmitEvent();
            formNode === null || formNode === void 0 ? void 0 : formNode.dispatchEvent(submitEvent);
            const onError = (_b = (_a = submitEvent.onError) !== null && _a !== void 0 ? _a : altConfig === null || altConfig === void 0 ? void 0 : altConfig.onError) !== null && _b !== void 0 ? _b : config.onError;
            const onSuccess = (_d = (_c = submitEvent.onSuccess) !== null && _c !== void 0 ? _c : altConfig === null || altConfig === void 0 ? void 0 : altConfig.onSuccess) !== null && _d !== void 0 ? _d : config.onSuccess;
            const onSubmit = (_g = (_f = (_e = submitEvent.onSubmit) !== null && _e !== void 0 ? _e : altConfig === null || altConfig === void 0 ? void 0 : altConfig.onSubmit) !== null && _f !== void 0 ? _f : config.onSubmit) !== null && _g !== void 0 ? _g : createDefaultSubmitHandler(formNode);
            if (!onSubmit)
                return;
            event === null || event === void 0 ? void 0 : event.preventDefault();
            if (submitEvent.defaultPrevented)
                return;
            isSubmitting.set(true);
            interacted.set(null);
            const currentData = deepRemoveKey(get(data));
            const currentErrors = await validateErrors(currentData, altConfig === null || altConfig === void 0 ? void 0 : altConfig.validate);
            const currentWarnings = await validateWarnings(currentData, altConfig === null || altConfig === void 0 ? void 0 : altConfig.warn);
            if (currentWarnings)
                warnings.set(_merge(deepSet(currentData, []), currentWarnings));
            touched.set(deepSetTouched(currentData, true));
            if (currentErrors) {
                touched.set(deepSetTouched(currentErrors, true));
                const hasErrors = deepSome(currentErrors, (error) => Array.isArray(error) ? error.length >= 1 : !!error);
                if (hasErrors) {
                    await new Promise((r) => setTimeout(r));
                    _getCurrentExtenders().forEach((extender) => {
                        var _a;
                        return (_a = extender.onSubmitError) === null || _a === void 0 ? void 0 : _a.call(extender, {
                            data: currentData,
                            errors: currentErrors,
                        });
                    });
                    isSubmitting.set(false);
                    return;
                }
            }
            const context = Object.assign(Object.assign({}, contextHelpers), { form: formNode, controls: formNode && Array.from(formNode.elements).filter(isFormControl), config: Object.assign(Object.assign({}, config), altConfig) });
            try {
                const response = await onSubmit(currentData, context);
                formNode === null || formNode === void 0 ? void 0 : formNode.dispatchEvent(createSuccessEvent(Object.assign({ response }, context)));
                await (onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(response, context));
            }
            catch (e) {
                const errorEvent = createErrorEvent(Object.assign({ error: e }, context));
                formNode === null || formNode === void 0 ? void 0 : formNode.dispatchEvent(errorEvent);
                if (!onError && !errorEvent.defaultPrevented) {
                    throw e;
                }
                if (!onError && !errorEvent.errors)
                    return;
                const serverErrors = errorEvent.errors || (await (onError === null || onError === void 0 ? void 0 : onError(e, context)));
                if (serverErrors) {
                    touched.set(deepSetTouched(serverErrors, true));
                    errors.set(serverErrors);
                    await new Promise((r) => setTimeout(r));
                    _getCurrentExtenders().forEach((extender) => {
                        var _a;
                        return (_a = extender.onSubmitError) === null || _a === void 0 ? void 0 : _a.call(extender, {
                            data: currentData,
                            errors: get(errors),
                        });
                    });
                }
            }
            finally {
                isSubmitting.set(false);
            }
        };
    }
    const handleSubmit = createSubmitHandler();
    function form(node) {
        if (!node.requestSubmit)
            node.requestSubmit = handleSubmit;
        function callExtender(stage) {
            return function (extender) {
                return extender({
                    form: node,
                    stage,
                    controls: Array.from(node.elements).filter(isFormControl),
                    data,
                    errors,
                    warnings,
                    touched,
                    config,
                    addValidator,
                    addTransformer,
                    setFields,
                    validate,
                    reset,
                });
            };
        }
        _setCurrentExtenders(extender.map(callExtender('MOUNT')));
        node.noValidate = !!config.validate;
        const { defaultData, defaultTouched } = getFormDefaultValues(node);
        _setFormNode(node);
        setInitialValues(_merge(_cloneDeep(defaultData), _getInitialValues()));
        setFields(_getInitialValues());
        touched.set(defaultTouched);
        function setCheckboxValues(target) {
            const elPath = getPath(target);
            const checkboxes = Array.from(node.querySelectorAll(`[name="${target.name}"]`)).filter((checkbox) => {
                if (!isFormControl(checkbox))
                    return false;
                return elPath === getPath(checkbox);
            });
            if (checkboxes.length === 0)
                return;
            if (checkboxes.length === 1) {
                return data.update(($data) => _set($data, getPath(target), target.checked));
            }
            return data.update(($data) => {
                return _set($data, getPath(target), checkboxes
                    .filter(isInputElement)
                    .filter((el) => el.checked)
                    .map((el) => el.value));
            });
        }
        function setRadioValues(target) {
            const radios = node.querySelectorAll(`[name="${target.name}"]`);
            const checkedRadio = Array.from(radios).find((el) => isInputElement(el) && el.checked);
            data.update(($data) => _set($data, getPath(target), checkedRadio === null || checkedRadio === void 0 ? void 0 : checkedRadio.value));
        }
        function setFileValue(target) {
            var _a;
            const files = Array.from((_a = target.files) !== null && _a !== void 0 ? _a : []);
            data.update(($data) => {
                return _set($data, getPath(target), target.multiple ? files : files[0]);
            });
        }
        function setSelectValue(target) {
            if (!target.multiple) {
                data.update(($data) => {
                    return _set($data, getPath(target), target.value);
                });
            }
            else {
                const selectedOptions = Array.from(target.options)
                    .filter((opt) => opt.selected)
                    .map((opt) => opt.value);
                data.update(($data) => {
                    return _set($data, getPath(target), selectedOptions);
                });
            }
        }
        function handleInput(e) {
            const target = e.target;
            if (!target ||
                !isFormControl(target) ||
                isSelectElement(target) ||
                shouldIgnore(target))
                return;
            if (['checkbox', 'radio', 'file'].includes(target.type))
                return;
            if (!target.name)
                return;
            isDirty.set(true);
            const inputValue = getInputTextOrNumber(target);
            interacted.set(target.name);
            data.update(($data) => {
                return _set($data, getPath(target), inputValue);
            });
        }
        function handleChange(e) {
            const target = e.target;
            if (!target || !isFormControl(target) || shouldIgnore(target))
                return;
            if (!target.name)
                return;
            setTouched(getPath(target), true);
            interacted.set(target.name);
            if (isSelectElement(target) ||
                ['checkbox', 'radio', 'file', 'hidden'].includes(target.type)) {
                isDirty.set(true);
            }
            if (target.type === 'hidden') {
                data.update(($data) => {
                    return _set($data, getPath(target), target.value);
                });
            }
            if (isSelectElement(target))
                setSelectValue(target);
            else if (!isInputElement(target))
                return;
            else if (target.type === 'checkbox')
                setCheckboxValues(target);
            else if (target.type === 'radio')
                setRadioValues(target);
            else if (target.type === 'file')
                setFileValue(target);
        }
        function handleBlur(e) {
            const target = e.target;
            if (!target || !isFormControl(target) || shouldIgnore(target))
                return;
            if (!target.name)
                return;
            setTouched(getPath(target), true);
            interacted.set(target.name);
        }
        function handleReset(e) {
            e.preventDefault();
            reset();
        }
        const mutationOptions = { childList: true, subtree: true };
        function unsetTaggedForRemove(formControls) {
            let currentData = get(data);
            let currentTouched = get(touched);
            let currentErrors = get(errors);
            let currentWarnings = get(warnings);
            for (const control of formControls.reverse()) {
                if (control.hasAttribute('data-felte-keep-on-remove') &&
                    control.dataset.felteKeepOnRemove !== 'false')
                    continue;
                const fieldArrayReg = /.*(\[[0-9]+\]|\.[0-9]+)\.[^.]+$/;
                let fieldName = getPath(control);
                const shape = get(touched);
                const isFieldArray = fieldArrayReg.test(fieldName);
                if (isFieldArray) {
                    const arrayPath = fieldName.split('.').slice(0, -1).join('.');
                    const valueToRemove = _get(shape, arrayPath);
                    if (_isPlainObject(valueToRemove) &&
                        Object.keys(valueToRemove).length <= 1) {
                        fieldName = arrayPath;
                    }
                }
                currentData = _unset(currentData, fieldName);
                currentTouched = _unset(currentTouched, fieldName);
                currentErrors = _unset(currentErrors, fieldName);
                currentWarnings = _unset(currentWarnings, fieldName);
            }
            data.set(currentData);
            touched.set(currentTouched);
            errors.set(currentErrors);
            warnings.set(currentWarnings);
        }
        const updateAddedNodes = debounce(() => {
            _getCurrentExtenders().forEach((extender) => { var _a; return (_a = extender.destroy) === null || _a === void 0 ? void 0 : _a.call(extender); });
            _setCurrentExtenders(extender.map(callExtender('UPDATE')));
            const { defaultData: newDefaultData, defaultTouched: newDefaultTouched, } = getFormDefaultValues(node);
            data.update(($data) => _defaultsDeep($data, newDefaultData));
            touched.update(($touched) => {
                return _defaultsDeep($touched, newDefaultTouched);
            });
        }, 0);
        let removedFormControls = [];
        const updateRemovedNodes = debounce(() => {
            _getCurrentExtenders().forEach((extender) => { var _a; return (_a = extender.destroy) === null || _a === void 0 ? void 0 : _a.call(extender); });
            _setCurrentExtenders(extender.map(callExtender('UPDATE')));
            unsetTaggedForRemove(removedFormControls);
            removedFormControls = [];
        }, 0);
        function mutationCallback(mutationList) {
            for (const mutation of mutationList) {
                if (mutation.type !== 'childList')
                    continue;
                if (mutation.addedNodes.length > 0) {
                    const shouldUpdate = Array.from(mutation.addedNodes).some((node) => {
                        if (!isElement(node))
                            return false;
                        if (isFormControl(node))
                            return true;
                        const formControls = getFormControls(node);
                        return formControls.length > 0;
                    });
                    if (!shouldUpdate)
                        continue;
                    updateAddedNodes();
                }
                if (mutation.removedNodes.length > 0) {
                    for (const removedNode of mutation.removedNodes) {
                        if (!isElement(removedNode))
                            continue;
                        const formControls = getFormControls(removedNode);
                        if (formControls.length === 0)
                            continue;
                        removedFormControls.push(...formControls);
                        updateRemovedNodes();
                    }
                }
            }
        }
        const observer = new MutationObserver(mutationCallback);
        observer.observe(node, mutationOptions);
        node.addEventListener('input', handleInput);
        node.addEventListener('change', handleChange);
        node.addEventListener('focusout', handleBlur);
        node.addEventListener('submit', handleSubmit);
        node.addEventListener('reset', handleReset);
        const unsubscribeErrors = errors.subscribe(($errors) => {
            for (const el of node.elements) {
                if (!isFormControl(el) || !el.name)
                    continue;
                const fieldErrors = _get($errors, getPath(el));
                const message = Array.isArray(fieldErrors)
                    ? fieldErrors.join('\n')
                    : typeof fieldErrors === 'string'
                        ? fieldErrors
                        : undefined;
                if (message === el.dataset.felteValidationMessage)
                    continue;
                if (message) {
                    el.dataset.felteValidationMessage = message;
                    el.setAttribute('aria-invalid', 'true');
                }
                else {
                    delete el.dataset.felteValidationMessage;
                    el.removeAttribute('aria-invalid');
                }
            }
        });
        return {
            destroy() {
                observer.disconnect();
                node.removeEventListener('input', handleInput);
                node.removeEventListener('change', handleChange);
                node.removeEventListener('focusout', handleBlur);
                node.removeEventListener('submit', handleSubmit);
                node.removeEventListener('reset', handleReset);
                unsubscribeErrors();
                _getCurrentExtenders().forEach((extender) => { var _a; return (_a = extender.destroy) === null || _a === void 0 ? void 0 : _a.call(extender); });
            },
        };
    }
    return {
        form,
        createSubmitHandler,
        handleSubmit,
    };
}

export { createFormAction };
//# sourceMappingURL=create-form-action.js.map
