import { _get, _set, _isPlainObject, deepSet, createId, _update, setForm, _cloneDeep, _unset } from '@felte/common';
import { get } from './get.js';
import { deepSetTouched } from './deep-set-touched.js';
import { deepSetKey } from './deep-set-key.js';

function addAtIndex(storeValue, path, value, index) {
    return _update(storeValue, path, (oldValue) => {
        if (typeof oldValue !== 'undefined' && !Array.isArray(oldValue))
            return oldValue;
        if (!oldValue)
            oldValue = [];
        if (typeof index === 'undefined') {
            oldValue.push(value);
        }
        else {
            oldValue.splice(index, 0, value);
        }
        return oldValue;
    });
}
function swapInArray(storeValue, path, from, to) {
    return _update(storeValue, path, (oldValue) => {
        if (!oldValue || !Array.isArray(oldValue))
            return oldValue;
        [oldValue[from], oldValue[to]] = [oldValue[to], oldValue[from]];
        return oldValue;
    });
}
function moveInArray(storeValue, path, from, to) {
    return _update(storeValue, path, (oldValue) => {
        if (!oldValue || !Array.isArray(oldValue))
            return oldValue;
        oldValue.splice(to, 0, oldValue.splice(from, 1)[0]);
        return oldValue;
    });
}
function isUpdater(value) {
    return typeof value === 'function';
}
function createSetHelper(storeSetter) {
    const setHelper = (pathOrValue, valueOrUpdater) => {
        if (typeof pathOrValue === 'string') {
            const path = pathOrValue;
            storeSetter((oldValue) => {
                const newValue = isUpdater(valueOrUpdater)
                    ? valueOrUpdater(_get(oldValue, path))
                    : valueOrUpdater;
                return _set(oldValue, path, newValue);
            });
        }
        else {
            storeSetter((oldValue) => isUpdater(pathOrValue) ? pathOrValue(oldValue) : pathOrValue);
        }
    };
    return setHelper;
}
function createHelpers({ stores, config, validateErrors, validateWarnings, }) {
    var _a;
    let formNode;
    let initialValues = deepSetKey(((_a = config.initialValues) !== null && _a !== void 0 ? _a : {}));
    const { data, touched, errors, warnings, isDirty, isSubmitting, interacted, } = stores;
    const setData = createSetHelper(data.update);
    const setTouched = createSetHelper(touched.update);
    const setErrors = createSetHelper(errors.update);
    const setWarnings = createSetHelper(warnings.update);
    function updateFields(updater) {
        setData((oldData) => {
            const newData = updater(oldData);
            if (formNode)
                setForm(formNode, newData);
            return newData;
        });
    }
    const setFields = (pathOrValue, valueOrUpdater, shouldTouch) => {
        const fieldsSetter = createSetHelper(updateFields);
        fieldsSetter(pathOrValue, valueOrUpdater);
        if (typeof pathOrValue === 'string' && shouldTouch) {
            setTouched(pathOrValue, true);
        }
    };
    function addField(path, value, index) {
        const touchedValue = _isPlainObject(value)
            ? deepSetTouched(value, false)
            : false;
        const errValue = _isPlainObject(touchedValue)
            ? deepSet(touchedValue, [])
            : [];
        value = _isPlainObject(value) ? Object.assign(Object.assign({}, value), { key: createId() }) : value;
        errors.update(($errors) => {
            return addAtIndex($errors, path, errValue, index);
        });
        warnings.update(($warnings) => {
            return addAtIndex($warnings, path, errValue, index);
        });
        touched.update(($touched) => {
            return addAtIndex($touched, path, touchedValue, index);
        });
        data.update(($data) => {
            const newData = addAtIndex($data, path, value, index);
            setTimeout(() => formNode && setForm(formNode, newData));
            return newData;
        });
    }
    function updateAll(updater) {
        errors.update(updater);
        warnings.update(updater);
        touched.update(updater);
        data.update(($data) => {
            const newData = updater($data);
            setTimeout(() => formNode && setForm(formNode, newData));
            return newData;
        });
    }
    function unsetField(path) {
        updateAll((storeValue) => _unset(storeValue, path));
    }
    function swapFields(path, from, to) {
        updateAll((storeValue) => swapInArray(storeValue, path, from, to));
    }
    function moveField(path, from, to) {
        updateAll((storeValue) => moveInArray(storeValue, path, from, to));
    }
    function resetField(path) {
        const initialValue = _get(initialValues, path);
        const touchedValue = _isPlainObject(initialValue)
            ? deepSetTouched(initialValue, false)
            : false;
        const errValue = _isPlainObject(touchedValue)
            ? deepSet(touchedValue, [])
            : [];
        data.update(($data) => {
            const newData = _set($data, path, initialValue);
            if (formNode)
                setForm(formNode, newData);
            return newData;
        });
        touched.update(($touched) => {
            return _set($touched, path, touchedValue);
        });
        errors.update(($errors) => {
            return _set($errors, path, errValue);
        });
        warnings.update(($warnings) => {
            return _set($warnings, path, errValue);
        });
    }
    const setIsSubmitting = createSetHelper(isSubmitting.update);
    const setIsDirty = createSetHelper(isDirty.update);
    const setInteracted = createSetHelper(interacted.update);
    async function validate() {
        const currentData = get(data);
        touched.set(deepSetTouched(currentData, true));
        interacted.set(null);
        const currentErrors = await validateErrors(currentData);
        await validateWarnings(currentData);
        return currentErrors;
    }
    function reset() {
        setFields(_cloneDeep(initialValues));
        setTouched(($touched) => deepSet($touched, false));
        interacted.set(null);
        isDirty.set(false);
    }
    const publicHelpers = {
        setData,
        setFields,
        setTouched,
        setErrors,
        setWarnings,
        setIsSubmitting,
        setIsDirty,
        setInteracted,
        validate,
        reset,
        unsetField,
        resetField,
        addField,
        swapFields,
        moveField,
        setInitialValues: (values) => {
            initialValues = deepSetKey(values);
        },
    };
    const privateHelpers = {
        _setFormNode(node) {
            formNode = node;
        },
        _getFormNode: () => formNode,
        _getInitialValues: () => initialValues,
    };
    return {
        public: publicHelpers,
        private: privateHelpers,
    };
}

export { createHelpers };
//# sourceMappingURL=helpers.js.map
